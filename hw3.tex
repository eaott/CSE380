\documentclass{article}
\usepackage[top=.5in, bottom=.5in, left=.9in, right=.9in]{geometry}
\usepackage[latin1]{inputenc}
\usepackage{enumerate}
\usepackage{hyperref}
\usepackage{graphics}
\usepackage{graphicx}
\usepackage{caption}
\usepackage{subcaption}
\usepackage{tabularx}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{siunitx}
\usepackage{mathtools}
\usepackage{bbm}



\usepackage[authoryear,round]{natbib}

% Use instead of natbib
%\usepackage[backend=bibtex,citestyle=authoryear-comp,natbib=true,sorting=none,hyperref=true,maxnames=2,arxiv=pdf]{biblatex}
%\renewbibmacro{in:}{}
%\addbibresource{/Users/Evan/GitProjects/tex-docs/references.bib}




\newcommand{\obar}[1]{\ensuremath{\overline{ #1 }}}
\newcommand{\iid}{\ensuremath{\stackrel{\textrm{iid}}{\sim}}}
\newcommand{\op}[2]{{\ensuremath{\underset{ #2 }{\operatorname{ #1 }}~}}}
\newcommand{\norm}[1]{{ \ensuremath{ \left\lVert  #1 \right\rVert  }  }}
\newcommand{\cov}{ \ensuremath{ \textrm{cov} } }
\newcommand{\var}{ \ensuremath{ \textrm{var} } }
\newcommand{\tr}{ \ensuremath{ \textrm{trace} } }
\newcommand{\df}{ \ensuremath{ \textrm{df} } }
\newcommand{\R}{ \ensuremath{ \mathbb{R} }}
\newcommand{\indicator}[1]{ \ensuremath{ \mathbbm{1}\left\{ #1 \right\} }   }

\usepackage{xcolor}
\definecolor{darkgreen}{rgb}{0,0.25,0}
\newcommand{\soln}{{\color{red}\textbf{Solution:~}\color{black}}}


\usepackage[formats]{listings}
\lstdefineformat{R}{~={\( \sim \)}}
\lstset{% general command to set parameter(s)
basicstyle=\small\ttfamily, % print whole listing small
keywordstyle=\bfseries\rmfamily,
keepspaces=true,
% underlined bold black keywords
commentstyle=\color{darkgreen}, % white comments
stringstyle=\ttfamily, % typewriter type for strings
showstringspaces=false,
numbers=left, numberstyle=\tiny, stepnumber=1, numbersep=5pt, %
frame=shadowbox,
rulesepcolor=\color{black},
,columns=fullflexible,format=R
} %
\renewcommand{\ttdefault}{cmtt}
% enumerate is numbered \begin{enumerate}[(I)] is cap roman in parens
% itemize is bulleted \begin{itemize}
% subfigures:
% \begin{subfigure}[b]{0.5\textwidth} \includegraphics{asdf.jpg} \caption{} \label{subfig:asdf} \end{subfigure}
\hypersetup{colorlinks=true, urlcolor=blue, linkcolor=blue, citecolor=blue}


\graphicspath{ {C:/Users/Evan/Desktop/} }
\title{\vspace{-6ex}CSE: HW 3\vspace{-2ex}}
\author{Evan Ott \\ UT EID: eao466\vspace{-2ex}}
%\date{DATE}
\setcounter{secnumdepth}{0}
\usepackage[parfill]{parskip}



\begin{document}
\maketitle

I plan to complete the canned project, but as previously discussed, I wanted to create a stretch goal to include MPI. 
I've used {\O}MQ in Python up at ARL to create a master-worker distributed system before for basic message passing,
so the concept of distributing computation across multiple nodes doesn't scare me. I just don't have experience using 
the more standard tool of MPI, and don't have experience running in a general-use environment like Stampede.

As for exactly what the goal is, I plan to write an additional version of the second problem in the canned project 
(charged particle motion in a vertical electric field) that will simulate trajectories for many (non-interacting)
particles across multiple
cores on more than one node. I'll probably use a master-worker solution wherein one core is responsible for
sending out initial conditions $(x_0, y_0, z_0, \dot{x}_0, \dot{y}_0, \dot{z}_0)$ to the other cores.

I know I could also configure the code to read from a common input file and select the conditions based on the
MPI rank field (taking indices where the modulus equals the rank, or similar), but I think it's slightly more of a
challenge to manage the message passing, especially
if there are more particles than total cores available for computation.

I will test the parallel computation's results against the one-off computation, to at least be sure nothing
gets lost in the message passing. Of course, I'll write all the code in a modular way so that the simulation code
will really be exactly the same whether it's being run using MPI or just a single core. Only the manner in which
it gets called will really change.

%\bibliographystyle{plainnat}
%\bibliography{/Users/Evan/GitProjects/tex-docs/references}

% If using biblatex
% \printbibliography

\end{document}